mod = comp, {comp};
comp = ["main"], "comp", ID, "{", {stmt}, "}";
stmt = decl | asmt | inst;
decl = ["in" | "out"], "bit", ID, [dim], ["=", expr], ";";
dim = "[", ["-"], DEC, "]";
asmt = ID, "=", expr, ";";
inst = "sub", ID, ["as", ID],";";

(* Expression rules *)
expr = term, exprDash;
exprDash = ("or" | "nor"), term, exprDash | ε;
term = fact, termDash;
termDash = ("xor" | "xnor"), fact, termDash | ε;
fact = prim, factDash;
factDash = ("and" | "nand"), prim, factDash | ε;
prim = "not", prim | "(", expr, ")" | ref | BIT_FD | conc;
ref = ID, ["[", DEC, [":", DEC ], "]" ];
conc = "<", expr, {",", expr }, ">";

(* Lexical rules *)
(* ¿ used to don't interfere with EBNF parsing *)
ID = ? @¿[A-Za-z_]\w*(\.[A-Za-z_]\w*)¿ ?;
DEC = ? 0 | [1-9][0-9]* ?;
BIT_FD = ? "([01]+)" ?;
